import org.openqa.selenium.*;
import org.openqa.selenium.By;
import org.openqa.selenium.WebDriver;
import org.openqa.selenium.WebElement;
import org.openqa.selenium.JavascriptExecutor;
import org.openqa.selenium.chrome.ChromeDriver;
import org.openqa.selenium.chrome.ChromeOptions;
import org.openqa.selenium.support.ui.WebDriverWait;
import org.openqa.selenium.support.ui.ExpectedConditions;
import org.openqa.selenium.interactions.Actions;
import io.github.bonigarcia.wdm.WebDriverManager;
import com.opencsv.CSVWriter;
import com.fasterxml.jackson.databind.ObjectMapper;
import com.fasterxml.jackson.databind.JsonNode;

import java.io.*;
import java.time.Duration;
import java.util.*;
import java.util.concurrent.TimeUnit;

public class JBLScrapper {
    
    private WebDriver driver;
    private WebDriverWait wait;
    private List<Product> products;
    private ObjectMapper objectMapper;
    
    // Product data class
    public static class Product {
        private String name;
        private String price;
        private String originalPrice;
        private String discount;
        private String availability;
        private String imageUrl;
        private String productUrl;
        private String category;
        private String color;
        private String description;
        
        // Constructors
        public Product() {}
        
        public Product(String name, String price, String availability, String imageUrl, String productUrl) {
            this.name = name;
            this.price = price;
            this.availability = availability;
            this.imageUrl = imageUrl;
            this.productUrl = productUrl;
        }
        
        // Getters and Setters
        public String getName() { return name; }
        public void setName(String name) { this.name = name; }
        
        public String getPrice() { return price; }
        public void setPrice(String price) { this.price = price; }
        
        public String getOriginalPrice() { return originalPrice; }
        public void setOriginalPrice(String originalPrice) { this.originalPrice = originalPrice; }
        
        public String getDiscount() { return discount; }
        public void setDiscount(String discount) { this.discount = discount; }
        
        public String getAvailability() { return availability; }
        public void setAvailability(String availability) { this.availability = availability; }
        
        public String getImageUrl() { return imageUrl; }
        public void setImageUrl(String imageUrl) { this.imageUrl = imageUrl; }
        
        public String getProductUrl() { return productUrl; }
        public void setProductUrl(String productUrl) { this.productUrl = productUrl; }
        
        public String getCategory() { return category; }
        public void setCategory(String category) { this.category = category; }
        
        public String getColor() { return color; }
        public void setColor(String color) { this.color = color; }
        
        public String getDescription() { return description; }
        public void setDescription(String description) { this.description = description; }
        
        @Override
        public String toString() {
            return "Product{" +
                    "name='" + name + '\'' +
                    ", price='" + price + '\'' +
                    ", availability='" + availability + '\'' +
                    ", imageUrl='" + imageUrl + '\'' +
                    '}';
        }
    }
    
    public JBLScrapper() {
        this.products = new ArrayList<>();
        this.objectMapper = new ObjectMapper();
    }
    
    /**
     * Initialize the WebDriver with Chrome browser
     */
    public void initializeDriver() {
        System.out.println("Initializing Chrome WebDriver...");
        
        // Setup ChromeDriver using WebDriverManager
        WebDriverManager.chromedriver().setup();
        
        // Configure Chrome options
        ChromeOptions options = new ChromeOptions();
        options.addArguments("--no-sandbox");
        options.addArguments("--disable-dev-shm-usage");
        options.addArguments("--disable-blink-features=AutomationControlled");
        options.addArguments("--user-agent=Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36");
        options.setExperimentalOption("excludeSwitches", new String[]{"enable-automation"});
        options.setExperimentalOption("useAutomationExtension", false);
        
        // Initialize driver
        this.driver = new ChromeDriver(options);
        this.wait = new WebDriverWait(driver, Duration.ofSeconds(20));
        
        // Maximize window
        driver.manage().window().maximize();
        driver.manage().timeouts().implicitlyWait(10, TimeUnit.SECONDS);
        
        System.out.println("WebDriver initialized successfully!");
    }
    
    /**
     * Navigate to a specific JBL page
     */
    public void navigateToPage(String url, String pageName) {
        System.out.println("Navigating to JBL " + pageName + " page...");
        driver.get(url);
        
        // Wait for page to load completely
        wait.until(ExpectedConditions.presenceOfElementLocated(By.tagName("body")));
        
        // Additional wait for dynamic content
        try {
            Thread.sleep(2000);
        } catch (InterruptedException e) {
            Thread.currentThread().interrupt();
        }
        
        System.out.println("Successfully navigated to: " + url);
    }
    
    /**
     * Navigate to multiple JBL pages and extract data
     */
    public void crawlMultiplePages() {
        System.out.println("Starting multi-page crawling...");
        
        // Define the pages to crawl
        String[][] pages = {
            {"https://ca.jbl.com/en_CA/home-audio/", "Home Audio"},
            {"https://ca.jbl.com/en_CA/party-speakers/", "Party Speakers"},
            {"https://ca.jbl.com/en_CA/sale/", "Sale"},
            {"https://ca.jbl.com/en_CA/bluetooth-speakers/", "Bluetooth Speakers"}
        };
        
        for (String[] page : pages) {
            try {
                System.out.println("\n=== Crawling " + page[1] + " ===");
                navigateToPage(page[0], page[1]);
                handlePopups();
                interactWithPageElements();
                extractProductDataFromCurrentPage();
                
                // Try to navigate through multiple pages within each category
                navigateThroughPages();
                
            } catch (Exception e) {
                System.err.println("Error crawling " + page[1] + ": " + e.getMessage());
            }
        }
    }
    
    /**
     * Handle popup windows and cookies with advanced Selenium features
     */
    public void handlePopups() {
        System.out.println("Handling popups and cookies...");
        
        try {
            // Wait for potential popup with explicit wait
            WebDriverWait popupWait = new WebDriverWait(driver, Duration.ofSeconds(5));
            
            // Look for common popup selectors with more comprehensive list
            String[] popupSelectors = {
                "button[aria-label='Close']",
                "button[aria-label='close']",
                ".modal-close",
                ".popup-close",
                "button[class*='close']",
                ".cookie-accept",
                "#cookie-accept",
                ".cookie-banner button",
                "[data-testid='close-button']",
                ".overlay-close",
                ".lightbox-close",
                "button[class*='dismiss']",
                ".notification-close"
            };
            
            boolean popupFound = false;
            for (String selector : popupSelectors) {
                try {
                    // Use explicit wait for each selector
                    WebElement popup = popupWait.until(ExpectedConditions.elementToBeClickable(By.cssSelector(selector)));
                    if (popup.isDisplayed() && popup.isEnabled()) {
                        // Scroll to element before clicking
                        ((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", popup);
                        Thread.sleep(500);
                        popup.click();
                        System.out.println("Closed popup using selector: " + selector);
                        popupFound = true;
                        break;
                    }
                } catch (Exception e) {
                    // Continue to next selector
                }
            }
            
            if (!popupFound) {
                System.out.println("No popups found or already closed");
            }
            
            // Additional wait for any remaining animations
            Thread.sleep(1000);
            
        } catch (Exception e) {
            System.out.println("Error handling popups: " + e.getMessage());
        }
    }
    
    /**
     * Interact with page elements using correct JBL selectors
     */
    public void interactWithPageElements() {
        System.out.println("Interacting with page elements...");
        
        try {
            // Wait for page to be fully loaded with JBL-specific selectors
            String[] productSelectors = {
                ".product-info",
                ".product-tile",
                ".product-item",
                ".product-card"
            };
            
            boolean productsFound = false;
            for (String selector : productSelectors) {
                try {
                    wait.until(ExpectedConditions.presenceOfElementLocated(By.cssSelector(selector)));
                    productsFound = true;
                    System.out.println("Found products using selector: " + selector);
                    break;
                } catch (Exception e) {
                    // Continue to next selector
                }
            }
            
            if (!productsFound) {
                System.out.println("No product containers found");
                return;
            }
            
            // Wait for dynamic content to load
            Thread.sleep(3000);
            
            // Try to interact with sort dropdown - JBL specific selectors
            String[] sortSelectors = {
                "select[name='sort']",
                ".sort-dropdown",
                "select[class*='sort']",
                ".sort-by select"
            };
            
            for (String selector : sortSelectors) {
                try {
                    WebElement sortDropdown = driver.findElement(By.cssSelector(selector));
                    if (sortDropdown.isDisplayed() && sortDropdown.isEnabled()) {
                        // Scroll to element
                        ((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", sortDropdown);
                        Thread.sleep(500);
                        sortDropdown.click();
                        System.out.println("Clicked on sort dropdown: " + selector);
                        break;
                    }
                } catch (Exception e) {
                    // Continue to next selector
                }
            }
            
            // Try to interact with filter options - JBL specific selectors
            String[] filterSelectors = {
                "//input[@type='checkbox' and contains(@value, '100-200')]",
                "//input[@type='checkbox' and contains(@value, '200-500')]",
                ".filter-checkbox",
                ".refinement-checkbox",
                "input[type='checkbox'][class*='filter']"
            };
            
            for (String selector : filterSelectors) {
                try {
                    WebElement filter = driver.findElement(By.xpath(selector));
                    if (filter.isDisplayed() && filter.isEnabled()) {
                        // Scroll to element
                        ((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", filter);
                        Thread.sleep(500);
                        filter.click();
                        System.out.println("Applied filter: " + selector);
                        // Wait for filter to apply
                        Thread.sleep(2000);
                        break;
                    }
                } catch (Exception e) {
                    // Continue to next selector
                }
            }
            
        } catch (Exception e) {
            System.out.println("Error interacting with page elements: " + e.getMessage());
        }
    }
    
    /**
     * Extract product data from the current page using correct JBL selectors
     */
    public void extractProductDataFromCurrentPage() {
        System.out.println("Extracting product data...");
        
        try {
            // Wait for products to load - JBL uses .product-info as the main container
            String[] productSelectors = {
                ".product-info",
                ".product-tile",
                ".product-item", 
                ".product-card"
            };
            
            List<WebElement> productTiles = new ArrayList<>();
            for (String selector : productSelectors) {
                try {
                    productTiles = driver.findElements(By.cssSelector(selector));
                    if (!productTiles.isEmpty()) {
                        System.out.println("Found " + productTiles.size() + " products using selector: " + selector);
                        break;
                    }
                } catch (Exception e) {
                    // Continue to next selector
                }
            }
            
            if (productTiles.isEmpty()) {
                System.out.println("No products found on current page");
                return;
            }
            
            for (WebElement productTile : productTiles) {
                try {
                    Product product = new Product();
                    
                    // Extract product name - JBL uses .product-name h3
                    try {
                        WebElement nameElement = productTile.findElement(By.cssSelector(".product-name h3, .product-name"));
                        product.setName(nameElement.getText().trim());
                    } catch (Exception e) {
                        product.setName("N/A");
                    }
                    
                    // Extract price - JBL uses .product-sales-price
                    try {
                        WebElement priceElement = productTile.findElement(By.cssSelector(".product-sales-price"));
                        product.setPrice(priceElement.getText().trim());
                    } catch (Exception e) {
                        product.setPrice("N/A");
                    }
                    
                    // Extract original price - JBL uses .product-standard-price
                    try {
                        WebElement originalPriceElement = productTile.findElement(By.cssSelector(".product-standard-price"));
                        product.setOriginalPrice(originalPriceElement.getText().trim());
                    } catch (Exception e) {
                        product.setOriginalPrice("N/A");
                    }
                    
                    // Extract discount - JBL uses .price-standard-save-percent
                    try {
                        WebElement discountElement = productTile.findElement(By.cssSelector(".price-standard-save-percent"));
                        product.setDiscount(discountElement.getText().trim());
                    } catch (Exception e) {
                        product.setDiscount("N/A");
                    }
                    
                    // Extract availability - JBL uses .availability
                    try {
                        WebElement availabilityElement = productTile.findElement(By.cssSelector(".availability"));
                        String availability = availabilityElement.getText().trim();
                        if (availability.isEmpty()) {
                            // Check for data attributes or other indicators
                            String availabilityClass = availabilityElement.getAttribute("class");
                            if (availabilityClass != null && availabilityClass.contains("in-stock")) {
                                availability = "In Stock";
                            } else {
                                availability = "In Stock"; // Default assumption
                            }
                        }
                        product.setAvailability(availability);
                    } catch (Exception e) {
                        product.setAvailability("In Stock"); // Default assumption
                    }
                    
                    // Extract image URL from swatch data
                    try {
                        // Try to get image from swatch data first
                        WebElement swatchData = productTile.findElement(By.cssSelector(".swatch-data"));
                        String swatchJson = swatchData.getText();
                        if (swatchJson.contains("thumbnailImageUrl")) {
                            // Parse JSON to extract image URL
                            String imageUrl = extractImageUrlFromJson(swatchJson);
                            product.setImageUrl(imageUrl);
                        } else {
                            // Fallback to regular img tag
                            WebElement imageElement = productTile.findElement(By.cssSelector("img"));
                            String imageUrl = imageElement.getAttribute("src");
                            if (imageUrl == null || imageUrl.isEmpty()) {
                                imageUrl = imageElement.getAttribute("data-src");
                            }
                            product.setImageUrl(imageUrl != null ? imageUrl : "N/A");
                        }
                    } catch (Exception e) {
                        product.setImageUrl("N/A");
                    }
                    
                    // Extract product URL - JBL uses .productname-link
                    try {
                        WebElement linkElement = productTile.findElement(By.cssSelector(".productname-link"));
                        product.setProductUrl(linkElement.getAttribute("href"));
                    } catch (Exception e) {
                        product.setProductUrl("N/A");
                    }
                    
                    // Extract color information from swatch
                    try {
                        WebElement colorElement = productTile.findElement(By.cssSelector(".swatch.selected img"));
                        product.setColor(colorElement.getAttribute("title"));
                    } catch (Exception e) {
                        product.setColor("N/A");
                    }
                    
                    // Extract description - JBL uses .product-description
                    try {
                        WebElement descriptionElement = productTile.findElement(By.cssSelector(".product-description"));
                        product.setDescription(descriptionElement.getText().trim());
                    } catch (Exception e) {
                        product.setDescription("N/A");
                    }
                    
                    // Set category based on current page
                    String currentUrl = driver.getCurrentUrl();
                    if (currentUrl.contains("party-speakers")) {
                        product.setCategory("Party Speakers");
                    } else if (currentUrl.contains("sale")) {
                        product.setCategory("Sale");
                    } else if (currentUrl.contains("bluetooth-speakers")) {
                        product.setCategory("Bluetooth Speakers");
                    } else {
                        product.setCategory("Home Audio");
                    }
                    
                    // Only add products with valid names
                    if (!product.getName().equals("N/A") && !product.getName().isEmpty()) {
                        products.add(product);
                        System.out.println("Extracted: " + product.getName() + " - " + product.getPrice());
                    }
                    
                } catch (Exception e) {
                    System.out.println("Error extracting product data: " + e.getMessage());
                }
            }
            
        } catch (Exception e) {
            System.out.println("Error during data extraction: " + e.getMessage());
        }
    }
    
    /**
     * Extract image URL from JSON data in swatch
     */
    private String extractImageUrlFromJson(String jsonData) {
        try {
            // Simple JSON parsing to extract thumbnailImageUrl
            if (jsonData.contains("\"thumbnailImageUrl\"")) {
                int startIndex = jsonData.indexOf("\"thumbnailImageUrl\":\"") + 21;
                int endIndex = jsonData.indexOf("\"", startIndex);
                if (startIndex > 20 && endIndex > startIndex) {
                    return jsonData.substring(startIndex, endIndex);
                }
            }
        } catch (Exception e) {
            System.out.println("Error parsing JSON for image URL: " + e.getMessage());
        }
        return "N/A";
    }
    
    /**
     * Helper method to extract text using multiple selectors
     */
    private String extractTextWithMultipleSelectors(WebElement parent, String[] selectors, String defaultValue) {
        for (String selector : selectors) {
            try {
                WebElement element = parent.findElement(By.cssSelector(selector));
                String text = element.getText().trim();
                if (!text.isEmpty()) {
                    return text;
                }
            } catch (Exception e) {
                // Continue to next selector
            }
        }
        return defaultValue;
    }
    
    /**
     * Navigate through multiple pages within a category
     */
    public void navigateThroughPages() {
        System.out.println("Navigating through pages within category...");
        
        try {
            int maxPages = 3; // Limit to 3 pages per category
            int currentPage = 1;
            
            while (currentPage <= maxPages) {
                System.out.println("Crawling page " + currentPage + " of category...");
                
                // Extract data from current page
                extractProductDataFromCurrentPage();
                
                // Try to find and click next page button with multiple selectors
                String[] nextButtonSelectors = {
                    ".pagination-next", ".next-page", "[aria-label='Next']",
                    ".pagination .next", ".page-next", ".load-more",
                    "button[class*='next']", ".pager-next"
                };
                
                boolean nextPageFound = false;
                for (String selector : nextButtonSelectors) {
                    try {
                        WebElement nextButton = driver.findElement(By.cssSelector(selector));
                        if (nextButton.isDisplayed() && nextButton.isEnabled()) {
                            // Scroll to element
                            ((JavascriptExecutor) driver).executeScript("arguments[0].scrollIntoView(true);", nextButton);
                            Thread.sleep(1000);
                            
                            // Click next button
                            nextButton.click();
                            
                            // Wait for page to load
                            Thread.sleep(3000);
                            currentPage++;
                            nextPageFound = true;
                            
                            System.out.println("Navigated to page " + currentPage);
                            break;
                        }
                    } catch (Exception e) {
                        // Continue to next selector
                    }
                }
                
                if (!nextPageFound) {
                    System.out.println("No more pages available in this category");
                    break;
                }
            }
            
        } catch (Exception e) {
            System.out.println("Error during page navigation: " + e.getMessage());
        }
    }
    
    /**
     * Save scraped data to CSV file
     */
    public void saveToCSV(String filename) {
        System.out.println("Saving data to CSV file: " + filename);
        
        try (CSVWriter writer = new CSVWriter(new FileWriter(filename))) {
            // Write header
            String[] header = {
                "Name", "Price", "Original Price", "Discount", "Availability", 
                "Image URL", "Product URL", "Category", "Color", "Description"
            };
            writer.writeNext(header);
            
            // Write product data
            for (Product product : products) {
                String[] row = {
                    product.getName(),
                    product.getPrice(),
                    product.getOriginalPrice(),
                    product.getDiscount(),
                    product.getAvailability(),
                    product.getImageUrl(),
                    product.getProductUrl(),
                    product.getCategory(),
                    product.getColor(),
                    product.getDescription()
                };
                writer.writeNext(row);
            }
            
            System.out.println("Successfully saved " + products.size() + " products to " + filename);
            
        } catch (IOException e) {
            System.err.println("Error saving to CSV: " + e.getMessage());
        }
    }
    
    /**
     * Save scraped data to JSON file
     */
    public void saveToJSON(String filename) {
        System.out.println("Saving data to JSON file: " + filename);
        
        try {
            objectMapper.writerWithDefaultPrettyPrinter()
                       .writeValue(new File(filename), products);
            System.out.println("Successfully saved data to " + filename);
        } catch (IOException e) {
            System.err.println("Error saving to JSON: " + e.getMessage());
        }
    }
    
    /**
     * Print summary of scraped data
     */
    public void printSummary() {
        System.out.println("\n=== SCRAPING SUMMARY ===");
        System.out.println("Total products scraped: " + products.size());
        
        if (!products.isEmpty()) {
            System.out.println("\nSample products:");
            for (int i = 0; i < Math.min(5, products.size()); i++) {
                System.out.println((i + 1) + ". " + products.get(i));
            }
        }
        
        // Count products by category
        Map<String, Integer> categoryCount = new HashMap<>();
        for (Product product : products) {
            categoryCount.merge(product.getCategory(), 1, Integer::sum);
        }
        
        System.out.println("\nProducts by category:");
        categoryCount.forEach((category, count) -> 
            System.out.println("- " + category + ": " + count + " products"));
    }
    
    /**
     * Close the WebDriver
     */
    public void closeDriver() {
        if (driver != null) {
            System.out.println("Closing WebDriver...");
            driver.quit();
        }
    }
    
    /**
     * Main method to run the enhanced scraper
     */
    public static void main(String[] args) {
        JBLScrapper scraper = new JBLScrapper();
        
        try {
            // Initialize WebDriver
            scraper.initializeDriver();
            
            // Crawl multiple pages with enhanced features
            scraper.crawlMultiplePages();
            
            // Save data to files
            scraper.saveToCSV("jbl_products.csv");
            scraper.saveToJSON("jbl_products.json");
            
            // Print summary
            scraper.printSummary();
            
        } catch (Exception e) {
            System.err.println("Error during scraping: " + e.getMessage());
            e.printStackTrace();
        } finally {
            // Always close the driver
            scraper.closeDriver();
        }
    }
}
